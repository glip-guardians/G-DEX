<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>G-DEX — GLIP</title>

<!-- ✅ Legacy backend constant (kept for compatibility; used for Pools rolling) -->
<script>
  const BACKEND_URL = "https://gdex-backend.onrender.com".replace(/\/$/, "");
</script>

<!-- PWA -->
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" href="G_DEX_icon.png">
<link rel="apple-touch-icon" href="G_DEX_icon.png">
<meta name="theme-color" content="#0b1e18" />

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js').catch(console.error);
    });
  }
</script>

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700&display=swap" rel="stylesheet">

<!-- Ethers v5 -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<style>
  :root{
    --bg0:#071510;
    --bg1:#0b1e18;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --stroke:rgba(255,255,255,.12);
    --stroke2:rgba(255,255,255,.18);
    --txt:#eaf7f0;
    --muted:rgba(234,247,240,.72);
    --green:#00ffb3;
    --green2:#00b478;
    --red:#ff4d4d;
    --gold:#ffd36e;
    --shadow: 0 18px 60px rgba(0,0,0,.35);
    --r:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:"Plus Jakarta Sans",system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(0,255,179,0.18), transparent 70%),
      radial-gradient(1200px 600px at 120% 120%, rgba(0,180,120,0.14), transparent 70%),
      linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)),
      var(--bg1);
    color:var(--txt);
    overflow-x:hidden;
  }
  a{color:var(--green); text-decoration:none}
  .wrap{max-width:1100px;margin:0 auto;padding:18px 14px 40px}
  header{
    position:sticky; top:0; z-index:50;
    margin:0 0 14px;
    padding:12px 12px;
    border:1px solid var(--stroke);
    border-radius:20px;
    background:rgba(11,30,24,.62);
    backdrop-filter: blur(10px) saturate(140%);
    box-shadow: var(--shadow);
  }
  .topbar{
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    flex-wrap:wrap;
  }
  .brand{
    display:flex; gap:10px; align-items:center;
    min-width:220px;
  }
  .brand img{
    width:38px;height:38px;border-radius:12px;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.06);
  }
  .brand .t1{font-weight:800; letter-spacing:.2px}
  .brand .t2{font-size:12px; color:var(--muted); margin-top:2px}
  nav{display:flex; gap:10px; flex-wrap:wrap; justify-content:center}
  .chip{
    display:inline-flex; align-items:center; justify-content:center;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.04);
    color:var(--txt);
    font-weight:700;
    font-size:14px;
  }
  .chip:hover{border-color:var(--stroke2)}
  .right{
    display:flex; gap:10px; align-items:center;
  }
  .btn{
    cursor:pointer;
    border:1px solid var(--stroke);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    color:#fff;
    border-radius:14px;
    padding:10px 12px;
    font-weight:800;
    font-size:14px;
    box-shadow:0 10px 28px rgba(0,0,0,.22);
  }
  .btn:hover{border-color:var(--stroke2)}
  .btn.primary{
    border-color:rgba(0,255,179,.35);
    background:linear-gradient(180deg, rgba(0,255,179,.18), rgba(0,180,120,.08));
  }
  .addr{
    font-size:12px;color:var(--muted);
    padding:10px 12px;border-radius:14px;border:1px solid var(--stroke);
    background:rgba(255,255,255,.04);
  }

  .grid{display:grid; grid-template-columns:1.15fr .85fr; gap:14px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr; } }

  .card{
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.06);
    border-radius:var(--r);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:14px 14px 10px;
    border-bottom:1px solid var(--stroke);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .card .hd h2{
    margin:0;
    font-size:16px;
    letter-spacing:.2px;
  }
  .card .hd .mini{
    font-size:12px;color:var(--muted)
  }
  .card .bd{padding:14px}
  .row{display:flex; gap:10px; align-items:center}
  .row + .row{margin-top:10px}

  .field{
    flex:1;
    border:1px solid var(--stroke);
    background:rgba(0,0,0,.18);
    border-radius:16px;
    padding:10px;
  }
  .field .label{
    display:flex; justify-content:space-between; align-items:center;
    font-size:12px; color:var(--muted); margin-bottom:8px;
  }
  .field .label .bal{font-size:12px;color:rgba(234,247,240,.76)}
  .inrow{display:flex; gap:10px; align-items:center}
  select, input{
    font-family:inherit;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.04);
    color:var(--txt);
    border-radius:14px;
    padding:10px 10px;
    font-weight:700;
    outline:none;
  }
  input{
    width:100%;
    background:transparent;
    border:0;
    padding:8px 6px;
    font-size:18px;
    font-weight:800;
  }
  .tokenSel{min-width:165px}
  .maxbtn{
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.05);
    color:#fff;
    padding:9px 10px;
    border-radius:12px;
    font-weight:800;
    cursor:pointer;
  }
  .maxbtn:hover{border-color:var(--stroke2)}
  .flip{
    width:44px; height:44px;
    border-radius:14px;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.04);
    cursor:pointer;
    font-size:18px;
    font-weight:900;
  }
  .flip:hover{border-color:var(--stroke2)}

  .subgrid{display:grid; grid-template-columns:1fr 1fr; gap:10px}
  @media (max-width:520px){ .subgrid{grid-template-columns:1fr; } }
  .pill{
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.04);
    border-radius:14px;
    padding:10px 12px;
    font-size:12px;
    color:var(--muted);
    display:flex; justify-content:space-between; gap:10px;
  }
  .pill b{color:var(--txt)}
  .status{
    margin-top:10px;
    font-size:13px;
    color:rgba(234,247,240,.84);
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--stroke);
    background:rgba(0,0,0,.18);
    word-break:break-word;
  }
  .status.warn{border-color:rgba(255,211,110,.35); color:rgba(255,211,110,.95)}
  .status.err{border-color:rgba(255,77,77,.35); color:rgba(255,77,77,.95)}
  .small{font-size:12px;color:var(--muted)}
  table{width:100%; border-collapse:collapse}
  th,td{
    padding:10px 8px;
    border-bottom:1px solid rgba(255,255,255,.08);
    text-align:left;
    font-size:13px;
  }
  th{color:rgba(234,247,240,.65); font-weight:800}
  .tag{
    display:inline-flex; align-items:center; gap:6px;
    border:1px solid rgba(0,255,179,.28);
    background:rgba(0,255,179,.08);
    color:rgba(234,247,240,.9);
    padding:6px 10px;border-radius:999px;
    font-size:12px;font-weight:900;
  }
</style>
</head>

<body>
<div class="wrap">

<header>
  <div class="topbar">
    <div class="brand">
      <img src="G_DEX_icon.png" alt="G-DEX">
      <div>
        <div class="t1">G-DEX</div>
        <div class="t2">GLIP • Sushi Router + Proxy fallback</div>
      </div>
    </div>

    <nav>
      <a class="chip" href="https://glipchain.com" target="_blank" rel="noopener">GLIPCHAIN</a>
      <a class="chip" href="https://gdex-app.com" target="_blank" rel="noopener">G-DEX</a>
      <a class="chip" href="#swap">Swap</a>
      <a class="chip" href="#pools">Pools</a>
    </nav>

    <div class="right">
      <div id="addr" class="addr">Not connected</div>
      <button id="btnConnect" class="btn primary">Connect</button>
    </div>
  </div>
</header>

<div class="grid">
  <!-- Swap -->
  <section id="swap" class="card">
    <div class="hd">
      <h2>Swap</h2>
      <div class="mini">
        <span class="tag" id="modeTag">AUTO</span>
      </div>
    </div>
    <div class="bd">

      <div class="field">
        <div class="label">
          <span>Sell</span>
          <span class="bal">Balance: <b id="balSell">—</b></span>
        </div>
        <div class="inrow">
          <div style="flex:1">
            <input id="sell" inputmode="decimal" placeholder="0.0" />
          </div>
          <button id="btnMax" class="maxbtn">Max</button>
          <select id="sellS" class="tokenSel"></select>
        </div>
      </div>

      <div class="row" style="justify-content:center;margin:10px 0;">
        <button id="btnFlip" class="flip">⇅</button>
      </div>

      <div class="field">
        <div class="label">
          <span>Buy (est.)</span>
          <span class="bal">Balance: <b id="balBuy">—</b></span>
        </div>
        <div class="inrow">
          <div style="flex:1">
            <input id="buy" inputmode="decimal" placeholder="0.0" disabled />
          </div>
          <select id="buyS" class="tokenSel"></select>
        </div>
      </div>

      <div class="subgrid" style="margin-top:12px">
        <div class="pill"><span>Slippage</span><b><span id="slipVal">20</span>%</b></div>
        <div class="pill"><span>Deadline</span><b>20m</b></div>
        <div class="pill"><span>Proxy flat fee</span><b id="feeFlat">—</b></div>
        <div class="pill"><span>Route</span><b id="routeTxt">—</b></div>
      </div>

      <div class="row" style="margin-top:12px">
        <input id="slip" type="range" min="1" max="35" value="20" style="flex:1">
        <button id="btnSwap" class="btn primary" style="min-width:150px">Swap</button>
      </div>

      <div id="swapStatus" class="status">Ready.</div>
      <div class="small" style="margin-top:10px; line-height:1.5">
        Notes:
        <br>• No tx hash → failed before sending (callStatic/estimateGas).
        <br>• Mobile MetaMask may fail estimation → this UI retries + uses safe gas limits.
        <br>• Proxy spender = Proxy Router, Direct spender = Sushi Router.
      </div>

    </div>
  </section>

  <!-- Pools -->
  <section id="pools" class="card">
    <div class="hd">
      <h2>Pools</h2>
      <div class="mini">Rolling list from backend</div>
    </div>
    <div class="bd">
      <div class="row" style="justify-content:space-between;gap:10px;flex-wrap:wrap">
        <div class="pill" style="flex:1"><span>Status</span><b id="poolStat">—</b></div>
        <button id="btnReloadPools" class="btn">Reload</button>
      </div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Pair</th>
              <th>LP</th>
              <th>Updated</th>
            </tr>
          </thead>
          <tbody id="poolRows">
            <tr><td colspan="3" class="small">Loading…</td></tr>
          </tbody>
        </table>
      </div>

      <div class="small" style="margin-top:10px">
        If pools don’t show, confirm backend CORS allows your domain.
      </div>
    </div>
  </section>
</div>

</div><!-- wrap -->

<script>
/* ============================================================
   ✅ Constants (Mainnet)
   ============================================================ */
const CHAIN_ID = 1;

const WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const SUSHI_ROUTER_V2 = "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F";

// ✅ Your addresses (based on your logs / history)
const GDEX_PROXY_ROUTER = "0x198C5B84dB9B1139092EDd9D56bE25653fEAC13D";

// Known tokens (add more if needed)
const TOKENS = [
  { symbol:"ETH",  name:"Ethereum", decimals:18, address:"ETH" },
  { symbol:"USDT", name:"Tether USD", decimals:6,  address:"0xdAC17F958D2ee523a2206206994597C13D831ec7" },
  { symbol:"GLIP", name:"GLIP",       decimals:18, address:"0xd0b86b79ae4b8d7bb88b37ebe228ce343d79794e" },
];

/* ============================================================
   ✅ Minimal ABIs
   ============================================================ */
const ERC20_ABI = [
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address owner,address spender) view returns (uint256)",
  "function approve(address spender,uint256 amount) returns (bool)",
];

const SUSHI_ROUTER_ABI = [
  "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",
  "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable returns (uint[] memory amounts)",
  "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)",
  "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)",
];

// Proxy Router ABI is uncertain → provide multiple candidates and auto-try them
const PROXY_ABI_CANDIDATES = [
  // Candidate A (tokenIn explicit + flatFee)
  [
    "function flatFeeWei() view returns (uint256)",
    "function feeRecipient() view returns (address)",
    "function swapExactTokensForTokensWithFee(address tokenIn,uint256 amountIn,uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
    "function swapExactTokensForETHWithFee(address tokenIn,uint256 amountIn,uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
    "function swapExactETHForTokensWithFee(uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
  ],
  // Candidate B (no tokenIn param)
  [
    "function flatFeeWei() view returns (uint256)",
    "function feeRecipient() view returns (address)",
    "function swapExactTokensForTokensWithFee(uint256 amountIn,uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
    "function swapExactTokensForETHWithFee(uint256 amountIn,uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
    "function swapExactETHForTokensWithFee(uint256 amountOutMin,uint256 flatFeeWei,address[] path,address to,uint256 deadline) payable",
  ],
  // Candidate C (fee inside msg.value only / no flatFee param)
  [
    "function flatFeeWei() view returns (uint256)",
    "function feeRecipient() view returns (address)",
    "function swapExactTokensForTokensWithFee(uint256 amountIn,uint256 amountOutMin,address[] path,address to,uint256 deadline) payable",
    "function swapExactTokensForETHWithFee(uint256 amountIn,uint256 amountOutMin,address[] path,address to,uint256 deadline) payable",
    "function swapExactETHForTokensWithFee(uint256 amountOutMin,address[] path,address to,uint256 deadline) payable",
  ],
];

/* ============================================================
   ✅ State
   ============================================================ */
let provider = null;
let signer = null;
let userAddress = null;

let __proxyFlatFeeWei = null;
let __proxyFeeRecipient = null;

let swapBusy = false;
let lastQuote = null; // { outBN, path, mode }

/* ============================================================
   ✅ UI helpers
   ============================================================ */
const $ = (id)=>document.getElementById(id);

function setSwapBusy(v){
  swapBusy = !!v;
  $("btnSwap").disabled = swapBusy;
  $("btnSwap").style.opacity = swapBusy ? 0.75 : 1;
}

function setSwapStatus(html, kind=""){
  const el = $("swapStatus");
  el.className = "status" + (kind ? (" " + kind) : "");
  el.innerHTML = html;
}

function dbg(...args){ console.log("[G-DEX]", ...args); }

function shortAddr(a){
  if(!a) return "";
  return a.slice(0,6)+"…"+a.slice(-4);
}

function showErrorPopup(title, text){
  // Minimal / non-blocking
  setSwapStatus(`<b>${title}</b><br><span style="opacity:.9">${escapeHtml(text).replace(/\n/g,"<br>")}</span>`, "err");
}

function escapeHtml(str){
  return String(str||"").replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[s]));
}

function metaIsETH(m){ return (m?.address === "ETH"); }
function addrForPath(m){ return metaIsETH(m) ? WETH : m.address; }

function getSelectedMeta(sel){
  const sym = sel.value;
  return TOKENS.find(t=>t.symbol===sym);
}

function bnFromInput(v, decimals){
  const s = String(v||"").trim();
  if(!s) return ethers.constants.Zero;
  return ethers.utils.parseUnits(s, decimals);
}

function bnToFloatStr(bn, decimals, maxFrac=6){
  try{
    const s = ethers.utils.formatUnits(bn, decimals);
    const [a,b] = s.split(".");
    if(!b) return a;
    return a + "." + b.slice(0, maxFrac);
  }catch{ return "0"; }
}

function calcOutMin(outBN, slipPct){
  const p = Math.max(0, Math.min(95, Number(slipPct||0)));
  const bp = Math.floor(p * 100);
  return outBN.mul(10000 - bp).div(10000);
}

/* ============================================================
   ✅ Mobile gas-estimation stabilization
   ============================================================ */
function isUnpredictableGasErr(e){
  const msg = (e?.message || String(e || "")).toLowerCase();
  return (
    e?.code === "UNPREDICTABLE_GAS_LIMIT" ||
    msg.includes("unpredictable_gas_limit") ||
    msg.includes("cannot estimate gas") ||
    msg.includes("execution reverted") ||
    msg.includes("revert")
  );
}

function relaxOutMin(outMinBN, extraSlipPct){
  const extra = Math.max(0, Math.min(95, Number(extraSlipPct || 0)));
  const bp = Math.floor(extra * 100);
  return outMinBN.mul(10000 - bp).div(10000);
}

function fallbackGasLimit(mode, sellIsEth, buyIsEth){
  if(mode === "proxy"){
    if (sellIsEth && !buyIsEth) return ethers.BigNumber.from("550000");
    if (!sellIsEth && buyIsEth) return ethers.BigNumber.from("750000");
    return ethers.BigNumber.from("850000");
  }else{
    if (sellIsEth && !buyIsEth) return ethers.BigNumber.from("420000");
    if (!sellIsEth && buyIsEth) return ethers.BigNumber.from("520000");
    return ethers.BigNumber.from("600000");
  }
}

/* ============================================================
   ✅ Web3 init
   ============================================================ */
function ensureWeb3(){
  if(!window.ethereum) throw new Error("No wallet found. Please install MetaMask.");
  provider = new ethers.providers.Web3Provider(window.ethereum, "any");
  signer = provider.getSigner();
}

async function ensureMainnet(){
  const net = await provider.getNetwork();
  if(net.chainId !== CHAIN_ID){
    throw new Error("Wrong network. Please switch to Ethereum Mainnet.");
  }
}

async function bindConnect(){
  $("btnConnect").addEventListener("click", connectWallet);
  if(window.ethereum){
    window.ethereum.on("accountsChanged", ()=>connectWallet(true).catch(()=>{}));
    window.ethereum.on("chainChanged", ()=>window.location.reload());
  }
}

async function connectWallet(silent=false){
  try{
    ensureWeb3();
    if(!silent){
      await provider.send("eth_requestAccounts", []);
    }
    userAddress = await signer.getAddress();
    $("addr").textContent = shortAddr(userAddress);
    $("btnConnect").textContent = "Connected";
    await refreshAllBalances();
    await loadProxyFeeParams();
    await updatePricePreview();
    setSwapStatus("Connected. Ready.");
  }catch(e){
    if(!silent) showErrorPopup("Connect failed", e?.message || String(e));
  }
}

/* ============================================================
   ✅ Allowance / balances
   ============================================================ */
async function erc20(addr){
  return new ethers.Contract(addr, ERC20_ABI, signer);
}

async function getBalance(meta){
  if(!userAddress) return ethers.constants.Zero;
  if(metaIsETH(meta)){
    return await provider.getBalance(userAddress);
  }else{
    const c = await erc20(meta.address);
    return await c.balanceOf(userAddress);
  }
}

async function ensureAllowance(meta, amountBN, spender){
  if(metaIsETH(meta)) return;
  const c = await erc20(meta.address);
  const cur = await c.allowance(userAddress, spender);
  if(cur.gte(amountBN)) return;

  setSwapStatus("Approving token… (this is a one-time step)");
  const tx = await c.approve(spender, ethers.constants.MaxUint256);
  setSwapStatus(`Approve sent: <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener">${tx.hash}</a>`);
  await tx.wait();
}

async function ensureSufficientTokenBalance(meta, amountBN){
  const bal = await getBalance(meta);
  if(bal.lt(amountBN)){
    throw new Error(`Insufficient ${meta.symbol} balance.`);
  }
}

async function ensureSufficientEthForValue(valueBN){
  const eth = await provider.getBalance(userAddress);
  // leave margin for gas (0.001 ETH)
  const margin = ethers.utils.parseEther("0.001");
  if(eth.lt(valueBN.add(margin))){
    throw new Error("Insufficient ETH for fee/value + gas.");
  }
}

async function refreshAllBalances(){
  try{
    const sellMeta = getSelectedMeta($("sellS"));
    const buyMeta  = getSelectedMeta($("buyS"));
    const bs = await getBalance(sellMeta);
    const bb = await getBalance(buyMeta);

    $("balSell").textContent = bnToFloatStr(bs, sellMeta.decimals, 6);
    $("balBuy").textContent  = bnToFloatStr(bb, buyMeta.decimals, 6);
  }catch(e){
    dbg("refreshAllBalances", e);
  }
}

/* ============================================================
   ✅ Proxy fee params
   ============================================================ */
async function loadProxyFeeParams(){
  __proxyFlatFeeWei = ethers.utils.parseEther("0.00003"); // default fallback
  __proxyFeeRecipient = null;

  for(const abi of PROXY_ABI_CANDIDATES){
    try{
      const c = new ethers.Contract(GDEX_PROXY_ROUTER, abi, provider);
      // If function exists, calls succeed
      const f = await c.flatFeeWei();
      __proxyFlatFeeWei = f;
      try{ __proxyFeeRecipient = await c.feeRecipient(); }catch{}
      break;
    }catch(e){
      // ignore
    }
  }

  $("feeFlat").textContent = __proxyFlatFeeWei
    ? (ethers.utils.formatEther(__proxyFlatFeeWei) + " ETH")
    : "—";
}

/* ============================================================
   ✅ Routing (simple heuristic)
   - If either side is WETH/ETH => direct [tokenIn, tokenOut]
   - Else route through WETH [tokenIn, WETH, tokenOut]
   ============================================================ */
function buildPath(tokenIn, tokenOut){
  if(tokenIn.toLowerCase() === tokenOut.toLowerCase()) return [tokenIn];
  if(tokenIn.toLowerCase() === WETH.toLowerCase() || tokenOut.toLowerCase() === WETH.toLowerCase()){
    return [tokenIn, tokenOut];
  }
  return [tokenIn, WETH, tokenOut];
}

async function quoteOut(amountInBN, path){
  const router = new ethers.Contract(SUSHI_ROUTER_V2, SUSHI_ROUTER_ABI, provider);
  const amts = await router.getAmountsOut(amountInBN, path);
  return amts[amts.length - 1];
}

/* ============================================================
   ✅ Plan resolver
   ============================================================ */
async function resolveWorkingPlanDirect({sellMeta,buyMeta,amountInBN_raw,tokenIn,tokenOut,to,deadline}){
  const path = buildPath(tokenIn, tokenOut);
  const outBN = await quoteOut(amountInBN_raw, path);
  const slipPct = Number($("slip").value || 20);
  const outMinBN = calcOutMin(outBN, slipPct);

  const sellIsEth = metaIsETH(sellMeta);
  const callValue = sellIsEth ? amountInBN_raw : ethers.constants.Zero;

  $("routeTxt").textContent = path.length === 2 ? "Direct" : "Via WETH";
  $("modeTag").textContent = "DIRECT";

  return { mode:"direct", path, outBN, outMinBN, callValue };
}

async function resolveWorkingPlanLite({sellMeta,buyMeta,amountInBN_raw,tokenIn,tokenOut,to,deadline}){
  // Proxy plan uses same quote path
  const path = buildPath(tokenIn, tokenOut);
  const outBN = await quoteOut(amountInBN_raw, path);
  const slipPct = Number($("slip").value || 20);
  const outMinBN = calcOutMin(outBN, slipPct);

  const sellIsEth = metaIsETH(sellMeta);
  const callValue = sellIsEth ? amountInBN_raw : (__proxyFlatFeeWei || ethers.utils.parseEther("0.00003"));

  $("routeTxt").textContent = (path.length === 2 ? "Direct" : "Via WETH") + " (Proxy)";
  $("modeTag").textContent = "PROXY";

  return { mode:"proxy", path, outBN, outMinBN, callValue };
}

/* ============================================================
   ✅ Estimate & send (Direct)
   ============================================================ */
async function estimateGasDirect({sellIsEth,buyIsEth,amountInBN_raw,outMinBN,path,to,deadline,callValue}){
  const router = new ethers.Contract(SUSHI_ROUTER_V2, SUSHI_ROUTER_ABI, signer);
  if(sellIsEth){
    return await router.estimateGas.swapExactETHForTokens(outMinBN, path, to, deadline, { value: callValue });
  }else if(buyIsEth){
    return await router.estimateGas.swapExactTokensForETH(amountInBN_raw, outMinBN, path, to, deadline);
  }else{
    return await router.estimateGas.swapExactTokensForTokens(amountInBN_raw, outMinBN, path, to, deadline);
  }
}

async function sendTxDirect({sellIsEth,buyIsEth,amountInBN_raw,outMinBN,path,to,deadline,callValue,gasLimit}){
  const router = new ethers.Contract(SUSHI_ROUTER_V2, SUSHI_ROUTER_ABI, signer);
  if(sellIsEth){
    return await router.swapExactETHForTokens(outMinBN, path, to, deadline, { value: callValue, gasLimit });
  }else if(buyIsEth){
    return await router.swapExactTokensForETH(amountInBN_raw, outMinBN, path, to, deadline, { gasLimit });
  }else{
    return await router.swapExactTokensForTokens(amountInBN_raw, outMinBN, path, to, deadline, { gasLimit });
  }
}

/* ============================================================
   ✅ Estimate & send (Proxy)
   - Auto-try multiple ABI candidate signatures.
   ============================================================ */
async function proxyContract(abi, withSigner=true){
  return new ethers.Contract(GDEX_PROXY_ROUTER, abi, withSigner ? signer : provider);
}

async function tryProxyCallStatic(abi, fnName, args, overrides){
  const c = await proxyContract(abi, true);
  if(!c[fnName]) throw new Error("fn_missing");
  // callStatic to test revert before send
  if(!c.callStatic[fnName]) throw new Error("callstatic_missing");
  return await c.callStatic[fnName](...args, overrides || {});
}

async function tryProxyEstimate(abi, fnName, args, overrides){
  const c = await proxyContract(abi, true);
  if(!c.estimateGas[fnName]) throw new Error("estimate_missing");
  return await c.estimateGas[fnName](...args, overrides || {});
}

async function tryProxySend(abi, fnName, args, overrides){
  const c = await proxyContract(abi, true);
  return await c[fnName](...args, overrides || {});
}

async function estimateGasLite({sellIsEth,buyIsEth,tokenInParam,amountInBN_raw,outMinBN,path,to,deadline,callValue}){
  const flat = __proxyFlatFeeWei || ethers.utils.parseEther("0.00003");

  const overrides = { value: callValue };

  // Try ABIs in order
  for(const abi of PROXY_ABI_CANDIDATES){
    try{
      // Determine fn + args by mode
      if(sellIsEth){
        // ETH -> Token
        const fns = [
          { fn:"swapExactETHForTokensWithFee", args:[outMinBN, flat, path, to, deadline] },
          { fn:"swapExactETHForTokensWithFee", args:[outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, overrides);
            return await tryProxyEstimate(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }else if(buyIsEth){
        // Token -> ETH
        const fns = [
          { fn:"swapExactTokensForETHWithFee", args:[tokenInParam, amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForETHWithFee", args:[amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForETHWithFee", args:[amountInBN_raw, outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, overrides);
            return await tryProxyEstimate(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }else{
        // Token -> Token
        const fns = [
          { fn:"swapExactTokensForTokensWithFee", args:[tokenInParam, amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForTokensWithFee", args:[amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForTokensWithFee", args:[amountInBN_raw, outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, overrides);
            return await tryProxyEstimate(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }
    }catch(e){
      // keep trying next ABI
    }
  }

  // If no ABI matched, throw so UI can fallback to Direct
  throw new Error("Proxy router ABI mismatch or call reverted.");
}

async function sendTxLite({sellIsEth,buyIsEth,tokenInParam,amountInBN_raw,outMinBN,path,to,deadline,callValue,gasLimit}){
  const flat = __proxyFlatFeeWei || ethers.utils.parseEther("0.00003");

  const overrides = { value: callValue, gasLimit };

  for(const abi of PROXY_ABI_CANDIDATES){
    try{
      if(sellIsEth){
        const fns = [
          { fn:"swapExactETHForTokensWithFee", args:[outMinBN, flat, path, to, deadline] },
          { fn:"swapExactETHForTokensWithFee", args:[outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, { value: callValue });
            return await tryProxySend(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }else if(buyIsEth){
        const fns = [
          { fn:"swapExactTokensForETHWithFee", args:[tokenInParam, amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForETHWithFee", args:[amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForETHWithFee", args:[amountInBN_raw, outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, { value: callValue });
            return await tryProxySend(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }else{
        const fns = [
          { fn:"swapExactTokensForTokensWithFee", args:[tokenInParam, amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForTokensWithFee", args:[amountInBN_raw, outMinBN, flat, path, to, deadline] },
          { fn:"swapExactTokensForTokensWithFee", args:[amountInBN_raw, outMinBN, path, to, deadline] },
        ];
        for(const t of fns){
          try{
            await tryProxyCallStatic(abi, t.fn, t.args, { value: callValue });
            return await tryProxySend(abi, t.fn, t.args, overrides);
          }catch(e){}
        }
      }
    }catch(e){}
  }

  throw new Error("Proxy send failed (ABI mismatch or reverted).");
}

/* ============================================================
   ✅ Recent tx (optional)
   ============================================================ */
function pushRecentTx(hash){
  // you can extend UI later
  dbg("TX:", hash);
}

/* ============================================================
   ✅ Preview quote
   ============================================================ */
let quoteTimer = null;
function scheduleQuote(){
  clearTimeout(quoteTimer);
  quoteTimer = setTimeout(()=>updatePricePreview().catch(()=>{}), 300);
}

async function updatePricePreview(){
  try{
    if(!provider) return;
    const sellMeta = getSelectedMeta($("sellS"));
    const buyMeta  = getSelectedMeta($("buyS"));
    const sellValStr = String($("sell").value || "").trim();
    if(!sellValStr || Number(sellValStr) <= 0){
      $("buy").value = "";
      $("routeTxt").textContent = "—";
      lastQuote = null;
      return;
    }

    await ensureMainnet();

    const tokenIn  = addrForPath(sellMeta);
    const tokenOut = addrForPath(buyMeta);
    const amountInBN_raw = bnFromInput(sellValStr, sellMeta.decimals);

    // Quote via Sushi router
    const path = buildPath(tokenIn, tokenOut);
    const outBN = await quoteOut(amountInBN_raw, path);
    $("buy").value = bnToFloatStr(outBN, buyMeta.decimals, 6);

    $("routeTxt").textContent = path.length === 2 ? "Direct" : "Via WETH";

    lastQuote = { outBN, path };
  }catch(e){
    dbg("updatePricePreview", e);
    // keep quiet
  }
}

/* ============================================================
   ✅ Swap main (with mobile stabilization)
   ============================================================ */
async function executeSwap() {
  try {
    setSwapStatus("Preparing…");
    if (!userAddress) {
      setSwapStatus("Please connect your wallet first.", "warn");
      return;
    }

    ensureWeb3();
    await ensureMainnet();
    await loadProxyFeeParams();

    const sellValStr = String($("sell").value || "").trim();
    if (!sellValStr || Number(sellValStr) <= 0) {
      setSwapStatus("Enter an amount to swap.", "warn");
      return;
    }

    const sellMeta = getSelectedMeta($("sellS"));
    const buyMeta  = getSelectedMeta($("buyS"));
    if (!sellMeta || !buyMeta) {
      setSwapStatus("Token metadata not found.", "err");
      return;
    }

    const amountInBN_raw = bnFromInput(sellValStr, sellMeta.decimals);
    if (amountInBN_raw.lte(0)) {
      setSwapStatus("Invalid amount.", "warn");
      return;
    }

    const sellIsEth = metaIsETH(sellMeta);
    const buyIsEth  = metaIsETH(buyMeta);
    if (sellIsEth && buyIsEth) {
      setSwapStatus("ETH → ETH swap is not supported.", "warn");
      return;
    }

    const tokenIn  = addrForPath(sellMeta);
    const tokenOut = addrForPath(buyMeta);
    const deadline = Math.floor(Date.now()/1000) + 1200;
    const to = userAddress;

    await ensureSufficientTokenBalance(sellMeta, amountInBN_raw);

    // approvals for proxy first (spender = proxy router)
    if (!sellIsEth) {
      setSwapStatus("Checking approval (Proxy)…");
      await ensureAllowance(sellMeta, amountInBN_raw, GDEX_PROXY_ROUTER);
    }

    const flat = (__proxyFlatFeeWei || ethers.utils.parseEther("0.00003"));
    const expectedValueProxy = sellIsEth ? amountInBN_raw : flat;
    await ensureSufficientEthForValue(expectedValueProxy);

    setSwapBusy(true);
    setSwapStatus("Preparing route…");

    let plan = null;
    let mode = "proxy";

    // 1) try proxy plan
    try{
      plan = await resolveWorkingPlanLite({ sellMeta, buyMeta, amountInBN_raw, tokenIn, tokenOut, to, deadline });
      mode = "proxy";
    }catch(proxyErr){
      dbg("proxy plan failed -> fallback to direct", proxyErr);
      plan = null;
    }

    // 2) if proxy failed, fallback to direct (and ensure Sushi allowance)
    if(!plan){
      if (!sellIsEth){
        setSwapStatus("Proxy failed. Switching to Direct mode… Checking Sushi approval…");
        await ensureAllowance(sellMeta, amountInBN_raw, SUSHI_ROUTER_V2);
      }else{
        setSwapStatus("Proxy failed. Switching to Direct mode…");
      }
      const expectedValueDirect = sellIsEth ? amountInBN_raw : ethers.constants.Zero;
      await ensureSufficientEthForValue(expectedValueDirect);

      plan = await resolveWorkingPlanDirect({ sellMeta, buyMeta, amountInBN_raw, tokenIn, tokenOut, to, deadline });
      mode = "direct";
    }

    // 3) estimate & send with stabilization
    setSwapStatus(`Sending transaction (${mode.toUpperCase()})…`);

    const tokenInParam = addrForPath(sellMeta);

    async function _estimateAndSendOnce(curPlan, attemptLabel){
      let gas = null;

      try{
        if(mode === "proxy"){
          gas = await estimateGasLite({
            sellIsEth, buyIsEth,
            tokenInParam,
            amountInBN_raw,
            outMinBN: curPlan.outMinBN,
            path: curPlan.path,
            to, deadline,
            callValue: curPlan.callValue
          });
        }else{
          gas = await estimateGasDirect({
            sellIsEth, buyIsEth,
            amountInBN_raw,
            outMinBN: curPlan.outMinBN,
            path: curPlan.path,
            to, deadline,
            callValue: curPlan.callValue
          });
        }
        gas = gas.mul(125).div(100);
      }catch(e){
        if(isUnpredictableGasErr(e)){
          dbg("estimateGas failed ("+attemptLabel+") using fallback gasLimit", e);
          setSwapStatus(`Gas estimation failed (${attemptLabel}). Using safe gas limit…`);
          gas = fallbackGasLimit(mode, sellIsEth, buyIsEth);
        }else{
          throw e;
        }
      }

      if(mode === "proxy"){
        return await sendTxLite({
          sellIsEth, buyIsEth,
          tokenInParam,
          amountInBN_raw,
          outMinBN: curPlan.outMinBN,
          path: curPlan.path,
          to, deadline,
          callValue: curPlan.callValue,
          gasLimit: gas
        });
      }else{
        return await sendTxDirect({
          sellIsEth, buyIsEth,
          amountInBN_raw,
          outMinBN: curPlan.outMinBN,
          path: curPlan.path,
          to, deadline,
          callValue: curPlan.callValue,
          gasLimit: gas
        });
      }
    }

    let tx = null;

    try{
      tx = await _estimateAndSendOnce(plan, "attempt-1");
    }catch(e1){
      if(isUnpredictableGasErr(e1)){
        const relaxed = { ...plan, outMinBN: relaxOutMin(plan.outMinBN, 25) };
        setSwapStatus(`Retrying with relaxed outMin… (${mode.toUpperCase()})`);
        tx = await _estimateAndSendOnce(relaxed, "attempt-2");
      }else{
        throw e1;
      }
    }

    pushRecentTx(tx.hash);

    setSwapStatus(
      `TX sent: <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" rel="noopener">${tx.hash}</a>`
    );

    setTimeout(()=>{ refreshAllBalances(); updatePricePreview(); }, 1500);

  } catch (err) {
    console.error("executeSwap error:", err);
    const msg = (err && err.message) ? err.message : String(err);

    showErrorPopup(
      "Swap failed",
      msg + "\n\nNote:\n" +
      "• If there is NO tx hash, it failed before sending (callStatic/estimateGas).\n" +
      "• Make sure you are on Ethereum Mainnet\n" +
      "• For proxy token swaps, ensure you have enough ETH for flat fee + gas\n" +
      "• Proxy mode spender = Proxy Router, Direct mode spender = Sushi Router\n" +
      "• Try higher slippage (10%~35%) if liquidity is thin\n" +
      "• Mobile gas estimation can fail; this UI retries + uses safe gas limits."
    );
  } finally {
    setSwapBusy(false);
  }
}

/* ============================================================
   ✅ Bind swap logic
   ============================================================ */
function bindSwapLogic(){
  // fill selects
  const sellS = $("sellS");
  const buyS  = $("buyS");
  sellS.innerHTML = "";
  buyS.innerHTML = "";

  TOKENS.forEach(t=>{
    const o1 = document.createElement("option");
    o1.value = t.symbol; o1.textContent = t.symbol;
    sellS.appendChild(o1);

    const o2 = document.createElement("option");
    o2.value = t.symbol; o2.textContent = t.symbol;
    buyS.appendChild(o2);
  });

  // defaults
  sellS.value = "USDT";
  buyS.value  = "GLIP";

  // slip UI
  $("slip").addEventListener("input", ()=>{
    $("slipVal").textContent = $("slip").value;
    scheduleQuote();
  });

  // input events
  $("sell").addEventListener("input", scheduleQuote);
  sellS.addEventListener("change", async ()=>{
    await refreshAllBalances();
    scheduleQuote();
  });
  buyS.addEventListener("change", async ()=>{
    await refreshAllBalances();
    scheduleQuote();
  });

  // flip
  $("btnFlip").addEventListener("click", async ()=>{
    const a = sellS.value;
    sellS.value = buyS.value;
    buyS.value  = a;
    $("sell").value = "";
    $("buy").value = "";
    await refreshAllBalances();
    scheduleQuote();
  });

  // max
  $("btnMax").addEventListener("click", async ()=>{
    try{
      if(!userAddress){ setSwapStatus("Connect wallet first.", "warn"); return; }
      const m = getSelectedMeta(sellS);
      const bal = await getBalance(m);
      // if ETH, keep margin
      let use = bal;
      if(metaIsETH(m)){
        const margin = ethers.utils.parseEther("0.001");
        use = bal.gt(margin) ? bal.sub(margin) : ethers.constants.Zero;
      }
      $("sell").value = bnToFloatStr(use, m.decimals, 6);
      scheduleQuote();
    }catch(e){
      dbg("max", e);
    }
  });

  // swap button
  $("btnSwap").addEventListener("click", executeSwap);

  // init
  $("slipVal").textContent = $("slip").value;
}

/* ============================================================
   ✅ Pools rolling
   ============================================================ */
async function fetchPools(){
  const tbody = $("poolRows");
  try{
    $("poolStat").textContent = "Loading…";
    tbody.innerHTML = `<tr><td colspan="3" class="small">Loading…</td></tr>`;

    const url = BACKEND_URL + "/pairs"; // adjust if your backend uses different path
    const res = await fetch(url, { cache:"no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    // expected: array of { pair, lp, updatedAt } but we’ll be flexible
    const rows = Array.isArray(data) ? data : (data?.pairs || []);
    if(!rows.length){
      tbody.innerHTML = `<tr><td colspan="3" class="small">No data.</td></tr>`;
      $("poolStat").textContent = "Empty";
      return;
    }

    tbody.innerHTML = rows.slice(0, 20).map(r=>{
      const pair = escapeHtml(r.pair || r.symbol || r.name || "—");
      const lp   = escapeHtml(r.lp || r.liquidity || r.address || "—");
      const up   = escapeHtml(r.updatedAt || r.updated || r.time || "");
      return `<tr>
        <td>${pair}</td>
        <td>${lp}</td>
        <td>${up}</td>
      </tr>`;
    }).join("");

    $("poolStat").textContent = "OK";
  }catch(e){
    dbg("fetchPools", e);
    $("poolStat").textContent = "Error";
    $("poolRows").innerHTML = `<tr><td colspan="3" class="small">Failed to load pools.</td></tr>`;
  }
}

function bindPools(){
  $("btnReloadPools").addEventListener("click", fetchPools);
  fetchPools();
  // rolling refresh
  setInterval(fetchPools, 20000);
}

/* ============================================================
   ✅ Boot
   ============================================================ */
window.addEventListener("DOMContentLoaded", () => {
  bindConnect();
  bindSwapLogic();
  bindPools();
});
</script>

</body>
</html>
